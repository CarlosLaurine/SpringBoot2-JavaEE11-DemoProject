package com.educandoweb.springBootStudies.entities;

import java.io.Serializable;
import java.time.Instant;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.MapsId;
import javax.persistence.OneToOne;
import javax.persistence.Table;

import com.educandoweb.springBootStudies.entities.Order;
import com.fasterxml.jackson.annotation.JsonIgnore;

//Defining it as a DataBase Table
@Entity

/*Signaling to JPA a new name for the auto-generated
Payment table at the database, in order to avoid conflicts
with the reserved word "ORDER" from SQL*/
@Table(name = "tb_payment")

/*Implementing Serializable interface in order to
allow Payment Objects to be transformed into
byte sequences, thus ensuring a broader perspective
of manipulation (net roaming, file imprinting, etc)
*/


public class Payment implements Serializable {
	
	//Serializable Serial Number
	private static final long serialVersionUID = 1L;
	

	//Defining its Primary Key attribute (id) as Auto-Generated by the DataBase
	@Id
	//Since this is a Numeric Key, it will be auto-incremented at the DataBase
	//To state this, the Mapping Command is the following, with the Auto-Incrementation Strategy defined between parenthesis
	@GeneratedValue(strategy= GenerationType.IDENTITY)
	
	public Long id;
	private Instant moment;
	
	
	/*Implementing the relation between Payment and Order (Many-to-Many)
	  and using the following annotation to indicate to JPA the relation
	  it needs to establish at the DataBase*/
	
	//Setting Association with Order
	@OneToOne
	
	/*Since, according to the flowchart, it is a One-To-One association,
	  first we need to identify the Dependent case (without which the 
	  other side of the association can still be included at the database).
	  In this case, the Dependent Class is Payment, so besides the Association
	  annotation (@OneToOne), another special annotation (@MapsId) is required 
	  for Payment Class  
	*/
	
	@MapsId
	
	/*Jackson Library (responsible for JSON Serialization) would produce an
    undesirable loop display if the following annotation wasn't stated. This happens because 
	  in this case, there would be a double-handed relation between Payment and Order. 
	  To fix this, it is enough to put the following annotation on one of the relation
	  sides.
	  */
	
	@JsonIgnore
	
	private Order order;
	
	public Payment () {
		
	}

	public Payment(Long id, Instant moment, Order order) {
		
		this.id = id;
		this.moment = moment;
		this.order = order;
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public Instant getMoment() {
		return moment;
	}

	public void setMoment(Instant moment) {
		this.moment = moment;
	}

	public Order getOrder() {
		return order;
	}

	public void setOrder(Order order) {
		this.order = order;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + (int) (id ^ (id >>> 32));
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Payment other = (Payment) obj;
		if (id != other.id)
			return false;
		return true;
	}
	
	
}
