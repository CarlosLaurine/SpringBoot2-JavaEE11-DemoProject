package com.educandoweb.springBootStudies.entities;

import java.io.Serializable;
import java.util.HashSet;
import java.util.Set;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.OneToMany;
import javax.persistence.Table;

import com.fasterxml.jackson.annotation.JsonIgnore;

//Defining it as a DataBase Table
@Entity

/*Signaling to JPA a new name for the auto-generated
Product table at the database, in order to avoid conflicts
with the reserved word "ORDER" from SQL*/
@Table(name = "tb_product")

/*Implementing Serializable interface in order to
allow Product Objects to be transformed into
byte sequences, thus ensuring a broader perspective
of manipulation (net roaming, file imprinting, etc)
*/

public class Product implements Serializable{

	//Serializable Serial Number

	private static final long serialVersionUID = 1L;
	
	//Defining its Primary Key attribute (id) as Auto-Generated by the DataBase
	@Id
	//Since this is a Numeric Key, it will be auto-incremented at the DataBase
	//To state this, the Mapping Command is the following, with the Auto-Incrementation Strategy defined between parenthesis
	@GeneratedValue(strategy= GenerationType.IDENTITY)
	
	private Long id;
	private String name;
	private String description;
	private Double price;
	private String imgUrl;
	
	
	//Defining Category Association
	
	/*To ensure that no Product will have more than one of the same Category,
	  it will be used another Java Collection other than List
	  to represent Product's relation with Orders. The Collection
	  that best fits this duty is Set due to its Mathematical Set's 
	  Nature and related features
	 */
	
	// OBS: All Collections should be instanced in an association

	/* OBS2: Friendly reminder that for collections the Set method is discarded,
	   only the Get one is used since the list should not change abruptly to another
	   list
	 */
	
    //OBS:The annotation @Transient prevents JPA from interpreting the element below
	
	//@Transient
	
	/*Implementing the relation between Product and Category (Many-to-Many)
	  and using the following annotation to indicate to JPA the relation
	  it needs to establish at the DataBase*/
	
	@ManyToMany
	
	//Using annotation @JoinColumn to create the Category/Product Association Table
	
	/*OBS: Between the parenthesis, the Table name will be set along with the Foreign Keys
	  that will associate both Product and Category. To the latter feature, the parameters to 
	  define the Table's Join Columns (or Foreign Keys), will be the following : joinColumns 
	  (to set the foreign keys' column for the products at the Association Table), and  
	  inverseJoinColumns (to define the Foreign Keys for the other side of the Association 
	  (In this case, the Categories) at the Association Table */
	
	@JoinTable(name = "tb_product_category", joinColumns = @JoinColumn(name = "product_id"),
	inverseJoinColumns = @JoinColumn(name = "category_id"))
	private Set<Category> categories = new HashSet<>();
	
	
	//Setting Product's Dependence to the Collection of OrderItems
	//Setting its Relation as One to Many
	//Mapping it according to OrderItemPk's Product Object's name (product)
	//OBS: to perform this method, first we call the OrderItem Attribute id, then we call its id's own Attribute "product" through (mappedBy = "id.product")
	
	@OneToMany(mappedBy = "id.product")	
	private Set<OrderItem> items = new HashSet<>();
	
	
	//Since a framework is being used, it is obligatory to set an empty constructor
	
	public Product() {
		
	}

	public Product(Long id, String name, String description, Double price, String imgUrl) {
		super();
		this.id = id;
		this.name = name;
		this.description = description;
		this.price = price;
		this.imgUrl = imgUrl;
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public Double getPrice() {
		return price;
	}

	public void setPrice(Double price) {
		this.price = price;
	}

	public String getImgUrl() {
		return imgUrl;
	}

	public void setImgUrl(String imgUrl) {
		this.imgUrl = imgUrl;
	}

	public Set<Category> getCategories() {
		return categories;
	}
	
	/*According to the Flowchart and Business Rules defined for this project, 
	  the Product will access not its OrderItems, which are between it and its Orders, 
	  but instead it will access its Orders themselves for applicability reasons. 
	  To perform this feature, a Get method will be created not to return a collection of OrderItems, 
	  but a collection of Orders associated to each OrderItem at the previously set Collection.
	  To do this, the method will create a  Set<Order> object and run through OrderItems Collection while 
	  filtering all Orders associated with each OrderItems and adding them to the new Order Collection
	  instantiated. Just then, it will return a brand new Order Collection and complete the 
	  Order-Access to the Product Class through the Get Method*/
	
	/*OBS: Since getOrders is NOT a direct Attribute of Product, the @JsonIgnore Annotation will be placed at its Get Method,
	  which is the significant part in this case for the Java Enterprise Platform since it
	  is through this initial point of the chain reaction that Json calls the associated Orders
	  and then starts the chain loop of calls (Product-Order-Product-Order, ad infinitum)*/
	
	@JsonIgnore
	
	public Set<Order> getOrders(){
		Set<Order> set = new HashSet<>();
		for(OrderItem item : items) {		
			set.add(item.getOrder());
		}
		return set;
	}
	
	
	//Setting HashCode and Equals based only on Product ID
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((id == null) ? 0 : id.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Product other = (Product) obj;
		if (id == null) {
			if (other.id != null)
				return false;
		} else if (!id.equals(other.id))
			return false;
		return true;
	}	
	
}
