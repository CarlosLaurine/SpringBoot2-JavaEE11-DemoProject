package com.educandoweb.springBootStudies.entities;

//Inserting JPA's Relational-Object Mapping at the Class

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.OneToMany;
import javax.persistence.Table;

import com.fasterxml.jackson.annotation.JsonIgnore;


//Defining it as a DataBase Table
@Entity

/*Signaling to JPA a new name for the auto-generated
Order table at the database, in order to avoid conflicts
with possible reserved word from SQL*/
@Table(name = "tb_user")

/*Implementing Serializable interface in order to
allow User Objects to be transformed into
byte sequences, thus ensuring a broader perspective
of manipulation (net roaming, file imprinting, etc)
*/

public class User implements Serializable {
	//Serializable Serial Number
	private static final long serialVersionUID = 1L;
	
	//Defining its Primary Key attribute (id) as Auto-Generated by the DataBase
	@Id
	//Since this is a Numeric Key, it will be auto-incremented at the DataBase
	//To state this, the Mapping Command is the following, with the Auto-Incrementation Strategy defined between parenthesis
	@GeneratedValue(strategy= GenerationType.IDENTITY)
	private Long id;
	private String name;
	private String email;
	private String phone;
	private String password;
	
	//Defining Order association
	//OBS: All Collections should be instanced in an association
	/*OBS2: Friendly reminder that for collections the Set method 
	  is discarded, only the Get one is used since the list should 
	  not change abruptly to another list*/
	
	/*Jackson Library (responsible for JSON Serialization) would indicate a
	  loop error if the following annotation wasn't stated. This happens because 
	  in this case, there would be a double-handed relation between User and Order. 
	  To fix this, it is enough to put the following annotation on one of the relation
	  sides. Preferably at the one that has the oneToMany relation with its pair since 
	  this way it will be possible for the JPA to load all the sides and dependencies
	  without running the risk of crashing the memory (since no Lazy Load will happen due 
	  to Jackson's direct solicitation to the JPA)
	  */
	
	@JsonIgnore
	
	/*Implementing the relation between User and Order (One-to-Many)
	  and using the following annotation to indicate to JPA the relation
	  it needs to establish at the DataBase. To this, the User-type attribute name 
	  defined at the other side of the association ("client") must be placed 
	  between the following parenthesis*/
	
	@OneToMany(mappedBy = "client")
	
	private List<Order> orders = new ArrayList<>();
	
	//Since a framework is being used, it is obligatory to set an empty constructor
	public User() {
		
	}


	public User(Long id, String name, String email, String phone, String password) {
		super();
		this.id = id;
		this.name = name;
		this.email = email;
		this.phone = phone;
		this.password = password;
	}


	public Long getId() {
		return id;
	}


	public void setId(Long id) {
		this.id = id;
	}


	public String getName() {
		return name;
	}


	public void setName(String name) {
		this.name = name;
	}


	public String getEmail() {
		return email;
	}


	public void setEmail(String email) {
		this.email = email;
	}


	public String getPhone() {
		return phone;
	}


	public void setPhone(String phone) {
		this.phone = phone;
	}


	public String getPassword() {
		return password;
	}


	public void setPassword(String password) {
		this.password = password;
	}

	public List<Order> getOrders() {
		return orders;
	}

	//Setting HashCode and Equals based only on User ID
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((id == null) ? 0 : id.hashCode());
		return result;
	}


	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		User other = (User) obj;
		if (id == null) {
			if (other.id != null)
				return false;
		} else if (!id.equals(other.id))
			return false;
		return true;
	}
	
	
	
	
	
	
}
