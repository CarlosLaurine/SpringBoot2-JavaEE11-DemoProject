package com.educandoweb.springBootStudies.entities;

//Inserting JPA's Relational-Object Mapping at the Class

import java.io.Serializable;
import java.util.HashSet;
import java.util.Set;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.ManyToMany;
import javax.persistence.Table;

import com.fasterxml.jackson.annotation.JsonIgnore;

//Defining it as a DataBase Table
@Entity

/*Signaling to JPA a new name for the auto-generated
Category table at the database, in order to avoid conflicts
with the reserved word "ORDER" from SQL*/
@Table(name = "tb_category")

/*Implementing Serializable interface in order to
allow Category Objects to be transformed into
byte sequences, thus ensuring a broader perspective
of manipulation (net roaming, file imprinting, etc)
*/

public class Category implements Serializable{
	//Serializable Serial Number
	private static final long serialVersionUID = 1L;
	
	//Defining its Primary Key attribute (id) as Auto-Generated by the DataBase
	@Id
	//Since this is a Numeric Key, it will be auto-incremented at the DataBase
	//To state this, the Mapping Command is the following, with the Auto-Incrementation Strategy defined between parenthesis
	@GeneratedValue(strategy= GenerationType.IDENTITY)
	
	private Long id;
	private String name;
	
	//Defining Product association
		
		/*To ensure that no Category will have more than one of the same Product,
		  it will be used another Java Collection other than List
		  to represent Product's relation with Orders. The Collection
		  that best fits this duty is Set due to its Mathematical Set's 
		  Nature and related features
		 */
	
		//OBS: All Collections should be instanced in an association
	
		/*OBS2: Friendly reminder that for collections the Set method 
		  is discarded, only the Get one is used since the list should 
		  not change abruptly to another list*/
		
		/*Jackson Library (responsible for JSON Serialization) would produce an
	      undesirable loop display if the following annotation wasn't stated. This happens because 
		  in this case, there would be a double-handed relation between Category and Product. 
		  To fix this, it is enough to put the following annotation on one of the relation
		  sides. Preferably at the one that has the oneToMany relation with its pair since 
		  this way it will be possible for the JPA to load all the sides and dependencies
		  without running the risk of crashing the memory (since no Lazy Load will happen due 
		  to Jackson's direct solicitation to the JPA)
		  */
		
		@JsonIgnore
		
		/*Implementing the relation between Category and Product (Many-to-Many)
		  and using the following annotation to indicate to JPA the relation
		  it needs to establish at the DataBase (Make a reference to the Mapping defined at Product). 
		  To relate to the Category/Product Association Table, the Category-type attribute name defined 
		  at the other side of the association ("categories") 
		  must be placed between the following parenthesis*/
		
		@ManyToMany(mappedBy = "categories")
	
	
	//OBS:The annotation @Transient prevents JPA from interpreting the element below
	
	//@Transient
	private Set<Product> products = new HashSet<>();
	
	//Since a framework is being used, it is obligatory to set an empty constructor

	public Category() {
		
	}


	public Category(Long id, String name) {
		super();
		this.id = id;
		this.name = name;
	}


	public Long getId() {
		return id;
	}


	public void setId(Long id) {
		this.id = id;
	}


	public String getName() {
		return name;
	}


	public void setName(String name) {
		this.name = name;
	}
	
	public Set<Product> getProducts() {
		return products;
	}

	//Setting HashCode and Equals based only on Category ID

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((id == null) ? 0 : id.hashCode());
		return result;
	}


	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Category other = (Category) obj;
		if (id == null) {
			if (other.id != null)
				return false;
		} else if (!id.equals(other.id))
			return false;
		return true;
	}	
	

}